
> 정리


프로세스가 하나 시작하려면 많은 자원이 필요하다. 만약 하나의 작업을 동시에 수행하려고 할 때 여러 개의 프로세스를 띄워서 실행하면 각각 메모리를 할당해줘야만 한다. 

JVM은 기본적으로 아무런 옵션 없이 실행하면 OS마다 다르지만 적어도 32MB ~ 64MB의 물리 메모리를 점유한다. 

그에 반해서 쓰레드를 하나 추가하면 1MB 이내의 메모리를 점유한다. 그래서 쓰레드를 경량 프로세스라고도 부른다. 

---

## 쓰레드를 생성하는 것은 크게 2가지 방법이 있다.

- 참고로 Thread 클래스는 Runnable 인터페이스를 구현한 클래스로 어떤 것을 적용하느냐의 차이만이 존재한다.

### Runnable 인터페이스를 사용하여

- Runnable 인터페이스를 구현한 클래스를 쓰레드로 바로 시작할 수 없다.
- 따라서 Thread 클래스의 생성자에 해당 객체를 추가하여 시작해줘야 한다.
- 이후 start 메서드를 호출하면 쓰레드가 시작된다.

<img width="472" alt="11111" src="https://user-images.githubusercontent.com/56379649/217295006-4e9f54e8-ce3a-4a77-9a97-23988e0b354c.png">

### Thread 클래스를 사용하여

- Thread 클래스를 사용할 경우 객체에 바로 start 메서드를 호출하여 쓰레드를 시작시킬 수 있다.

<img width="421" alt="2222" src="https://user-images.githubusercontent.com/56379649/217294997-98a856d3-eb5d-458a-96a5-3596eac8b9a6.png">

### 쓰레드 수행 클래스

<img width="476" alt="3333" src="https://user-images.githubusercontent.com/56379649/217294978-3c1f4b63-0752-4115-9c31-1c3bb9d3cca7.png">

- 그렇다면 왜 두 가지 방법을 제공할까
    - 자바에서는 하나의 클래스만 확장할 수 있다.
    - 만약에 어떤 클래스가 어떤 다른 클래스의 extends를 사용해야 하는 상황인데, 쓰레드로 구현해야 한다. 게다가 그 부모 클래스는 thread를 확장하지 않은 상황이다.  어떻게 해야 할까
    - 자바에서 Thread 클래스를 확장받아야만 쓰레드를 구현할 수 있는데, 다중 상속이 불가능 하므로 해당 클래스는 쓰레드를 만들 수 없다.
    - 하지만 인터페이스는 여러 개의 인터페이스를 구현해도 문제가 되지 않는다.
    - 따라서 이러한 경우에 Runnable 인터페이스를 구현해서 사용하면 되는 것이다.
    
    - 정리하자면
    - 쓰레드 클래스가 다른 클래스를 확장할 필요가 있을 경우 Runnable 인터페이스를 구현하면 되며,
    - 그렇지 않은 경우에는 쓰레드 클래스를 사용하는 것이 편하다.
    

---

- 쓰레드라는 것을 start 메서드를 통해서 시작했다는 것은 
프로세스가 아닌 하나의 쓰레드를 JVM에 추가하여 실행한다는 의미이다.

<img width="1853" alt="4444" src="https://user-images.githubusercontent.com/56379649/217294906-0a221925-6365-4e1f-9c93-598c733180bf.png">

---

- Thread.sleep() 메서드를 사용할 때에는 항상 try-catch문으로 묶어주고, `InterruptedException`으로 catch해주어야 한다.
    - 그 이유는 다음과 같이 해당 예외를 던질 수도 있다고 선언되어 있기 때문이다.
    
    ```jsx
    public static native void sleep(long millis) throws InterruptedException;
    ```
    

---

## 데몬 쓰레드

- 데몬쓰레드는 해당 쓰레드가 종료되지 않아도 다른 실행 중인 일반 쓰레드가 없다면 프로세스가 중지되는 특징을 갖는다.

- 그러면 왜 데몬 쓰레드를 사용할까
    - 모니터링하는 쓰레드를 별도로 띄워 모니터링하다가 주요 쓰레드가 종료되면 관련된 모니터링 쓰레드가 종료되어야 프로세스가 종료될 수 있다.
    - 그런데 모니터링 쓰레드를 데몬 쓰로드로 만들지 않으면 프로세스가 종료될 수 없게 된다.
    - 이렇게 부가적인 작업을 수행하는 쓰레드를 선언할 때에 데몬 쓰레드를 만들어 사용하는 것이다.
    
    ```jsx
    ThreadSample thread = new ThreadSample();
    thread.setDaemon(true);
    ```
    

---

### 쓰레드와 관련이 많은 synchronized

- 여러 쓰레드가 한 객체에 선언된 메서드에 접근하여 데이터를 처리하려고 할 때 동시에 연산을 수행하여 값이 꼬이는 경우가 발생할 수 있다.
- 단, 메서드에서 인스턴스 변수를 수정하려고 할 때에만 이러한 문제가 발생한다.
- 매개 변수나 메서드에서만 사용하는 지역 변수만 다루는 메서드는 전혀 synchronized로 선언할 필요가 없다.

### synchronized 사용 방법

1. 메서드 자체를 synchronized로 선언하는 방법

```jsx
public synchronized void plus(int value){ // 메서드 자체 동기화
	amount += value;
}
```

1. 다른 하나는 메서드 내의 특정 문장만 synchronized로 감싸는 방법

```jsx
public void plus(int value){
	synchronized(this){ // 한 명의 쓰레드만 일을 할 수 있도록 허용해준다.
		amount += value;
	}
}
```

### StringBuffer : 하나의 문자열 객체를 여러 쓰레드에서 공유해야 할 때 사용

⇒ Thread Safe

### StringBuilder : 여러 쓰레드에서 공유할 일이 없는 경우에 사용

---

### 쓰레드 클래스에서 join() 메서드

- join 메서드는 해당 쓰레드가 종료될 때까지 기다린다.
- 매개 변수가 없을 경우 해당 쓰레드가 끝날 때까지 무한으로 대기한다.

### 쓰레드 클래스에서 interrupt() 메서드

- 현재 수행 중인 쓰레드를 중단시킨다.
- 허나, 그냥 중지시키지 않고 InterruptedException을 발생시키면서 중단시킨다.

- 만약 쓰레드가 시작하기 전이나 종료된 상태에 interrupt() 메서드를 호출하는 상황에서는 예외나 에러없이 다음 문장으로 넘어가게 된다.

- 추가로 stop() 메서드도 있었으나, 안전상의 이유로 deprecated되어, interrupt() 메서드를 이용하여 쓰레드를 멈추어야 한다.

---

### ThreadGroup에 대하여

- ThreadGroup 클래스는 쓰레드의 관리를 용이하게 하기 위한 클래스이다.
- 해당 클래스 내 enumerate() 메서드는 해당 쓰레드 그룹에 포함된 쓰레드나 쓰레드 그룹의 목록을 매개 변수로 넘어온 배열에 담는다.
- 쓰레드 객체 내 모든 객체를 제대로 담으려면 activeCount() 메서드를 통해 쓰레드 개수를 파악 후, 해당 개수만큼 배열을 생성하면 된다.
