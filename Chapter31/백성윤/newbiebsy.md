# Chapter 31 Java 7에 추가된 것들에는?

### Fork/Join 은 cpu를 더 쉽게, 효율적으로 사용하기 위해서 만들어진 거에요.

> Java 7 에서 추가된 클래스 중에는 **Fork/Join**과 관련된 클래스들이 존재한다. 여기서 Fork/Join 이라는 것은
> 어떤 계산 작업을 할 때 "여러 개로 나누어 계산한 후 결과를 모으는 작업"을 의미한다.   
> 
> 여기서 Fork 는 "여러 개로 나누는 것"을 말하고 Join 은 "나누어서 작업한 결과를 모으는 것"을 말한다.
> 
> 그런데, Java 7 에서 추가된 Fork/Join 은 단순하게 작업을 쪼개고 그 결과만을 받는 단순한 작업만을 포함하지 않는다.
> 여기에는 **Work Stealing**이라는 개념이 기본적으로 포함되어 있다.
> 
> work Stealing 은 여러 개의 덱에 작업이 나뉘어져 어떤 일이 진행될 때, 특정 덱의 작업이 끝나면 아직 작업이 끝나지 않은 다른 덱의
> 작업을 가져가서 처리하는 것을 말한다.
> 
> Fork/Join 작업의 기본 수행 개념은 다음과 같다.
> ```java
>  if (작업의 단위가 충분히 적을 경우) {
>   해당 작업을 수행
> } else {
>   작업을 반으로 쪼개어 두 개의 작업으로 나눔
>   두 작업을 동시에 실행시키고, 두 작업이 끝날 때까지 결과를 기다림
> }
> ```
> 이러한 식으로 Fork/Join이 실행되기 때문에 보통 이 연산은 회귀적으로 수행될 때 많이 사용된다.
> 
> Fork/Join 기능은 java.util.concurrent 패키지의 RecursiveAction 과 RecursiveTask 라는 abstract 클래스를 사용해야 한다.   
> 두 개의 클래스를 비교해 보면

| 구분      | RecursiveTask | RecursiveAction |
|---------|---------------|-----------------|
| Generic | O             | X               |
| 결과 리턴   | O             | X               |

> 큰 차이는 위와 같다.
> 두 클래스 모두 ForkJoinTask 라는 abstract 클래스를 확장했는데, 이 클래스는 Future라는 인터페이스를 구현했다.
> 
> 여기서 Future라는 인터페이스는 "비동기적인 요청을 하고 응답을 기대릴 때" 사용된다.
> 
> Fork/Join 작업을 수행하려면 RecursiveAction, RecursiveTask 두 클래스를 확장하여 개발하면 된다.
> 두 클래스 모두 compute() 메소드가 재귀 호출되고, 연산을 수행한다고 보면 된다.
> 
> 작업을 수행하는 클래스를 만든 후에는 ForkJoinPool 클래스를 사용하여 작업을 시작한다. 
> 이 클래스에서 제공하는 메소드는 용도에 따라서 다음과 같이 구분하여 사용한다.

|                   | Fork/Join 클라이언트 밖에서 호출 | Fork/Join 클라이언트 내에서 호출 |
|-------------------|------------------------|------------------------|
| 비 동기적 호출 수행시      | execute(ForkJoinTask)  | ForkJonTask.fork()     |
| 호출 후 결과 대기        | invoke(ForkJoinTask)   | ForkJonTask.invoke()   |
| 호출 후 Future 객체 수신 | submit(ForkJoinTask)   | ForkJonTask.fork()     |

> 참고로 Fork/Join 은 계산이 복잡할수록 효과가 크며, 계산을 수행하기 위해서 쓰레드를 관리할 필요가 없다는 것이 핵심이다.
> (쓰레드는 cpu의 개수만큼 증가한다.)


### NIO2

> NIO2 는 자바에서 지금까지 다루지 않은 "파일의 속성"을 다룰 수 있고, 심볼릭 링크 까지 처리할 수 있는 기능을 제공한다.
> 또한 파일이 변경되었는지를 쉽게 확인할 수 있는 WatchService라는 클래스도 제공된다.
> 
> java.io 패키지의 File 클래스는 이름만 File 이고, 실제로는 경로에 대한 정보를 담을 수 있어 사용할 때 많은 혼돈이 있었다.   
> NIO2에서 이러한 File 클래스를 대체하는 클래스들을 알아보자

| 클래스         | 설명                                                                                                                                                                      |
|-------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Paths       | 이 클래스에서 제공하는 static한 get() 메소드를 사용하면 Path라는 인터페이스의 객체를 얻을 수 있다. 여기서 Path라는 인터페이스는 파일과 경로에 대한 정보를 갖고 있다.                                                                 |
| Files       | 기존 File 클래스에서 제공되던 클래스의 단점들을 보완한 클래스다. 매우 많은 메소드들을 제공하며, Path 객체를 사용하여 파일을 통제하는데 사용된다.                                                                                  |
| FileSystems | 현재 사용중인 파일 시스템에 대한 정보를 처리하는 데 필요한 메소드를 제공한다. Paths와 마찬가지로 이 클래스에서 제공되는 static한 getDefault() 메소드를 사용하면 현재 사용중인 기본 파일 시스템에 대한 정보를 갖고 있는 FileSystem이라는 인터페이스의 객체를 얻을 수 있다. |
| FileStore   | 파일을 저장하는 디바이스, 파티션, 볼륨 등에 대한 정보들을 확인하는 데 필요한 메소드를 제공한다.                                                                                                                 |

> 위의 모든 클래스들은 java.nio.file 이라는 패키지에 위치하고 있다.
> 
> 먼저 Paths 클래스를 보면, 생성자가 존재하지 않고 두 개의 static한 get() 메소드를 통해 Path 객체를 얻을 수 있다.

| 리턴 타입       | 메소드                               |
|-------------|-----------------------------------|
| static Path | get(String first, String... more) |
| static Path | get(URI uri)                      |

> 위에서 보는 것과 같이 디렉토리의 경로를 문자열로 지정하여 Path 객체를 얻을 수도 있고,
> URI 정보를 갖고 Path 객체를 얻을 수도 있다.
> 그리고, java,io 패키지에 있는 File 클래스의 toPath() 라는 메소드를 통해서도 Path 객체를 얻을 수 있다.
> 
> Path에 정의된 relativize(), toAbsolutePath(), normalize(), resolve() 에 대해서 간단히 알아보자.
> - relativize() 메소드는 매개 변수로 넘긴 Path와 현재 Path와의 상대 경로를 리턴한다.
즉, 현재 Path에서 매개 변수로 넘긴 경로로 커맨드 창으로 이동하려고 할 때 어떻게 이동해야 할지를 알려준다.
> - toAbsolutePath() 메소드는 relativize() 메소드의 결과와 같이 상대 경로로 되어 있는 것을 절대 경로로 변경한다.
여기서의 절대 경로에는 ".."과 같은 경로는 그대로 남게 된다.
> - normalize() 메소드는 경로상에 있는 "." 이나 ".." 을 없애는 작업을 한다.
> - resolve() 메소드는 매개 변수로 넘어온 문자열을 하나의 경로로 생각하고, 현재 Path의 가장 마지막 path로 추가한다. 참고로 이 메소드는 Path를 매개 변수로 받기도 한다.

### Files 클래스는 파일을 다루기 위한 클래스랍니다.

> Files 클래스는 기존의 File 클래스에서 제공되는 기능보다 더 많은 기능을 제공한다.
> - 복사 및 이동
> - 파일, 디렉토리 등 생성
> - 삭제
> - 읽기와 쓰기
> - Stream 및 객체 생성
> - 각종 확인 (get,is 로 시작되는 메소드들로 파일의 상태를 확인함)
> 
> 매우 많은 메소드가 존재하기 때문에 API 문서를 참고하자.
> 
> 