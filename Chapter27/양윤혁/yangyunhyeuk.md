

> 정리
> 

## Serializable 인터페이스를 구현하는 이유

- 생성한 객체를 파일로 저장할 일이 있는 경우
- 저장한 객체를 읽을 일이 있는 경우
- 객체를 다른 서버로 보낼 때가 있는 경우
- 다른 서버에서 생성한 객체를 받을 일이 있는 경우

- Serializable 인터페이스를 구현하면 JVM에서 해당 객체는 저장하거나 다른 서버로 전송할 수 있도록 해준다.
- 해당 인터페이스 구현 시 serialVersionUID라는 값을 지정해주는 것을 권장한다.
    - 별도로 지정하지 않을 시 자바 소스가 컴파일 될 때 자동으로 생성된다.
    - 해당 값은 해당 객체의 버전을 명시할 때에 사용된다.
    - 이는 각 서버가 쉽게 해당 객체가 같은지 다른지를 확인할 수 있도록 하기 위함이다.
    - 서버에서 다른 클래스라고 인식하는 경우
        - 클래스 이름이 같더라도 해당 UID가 다른 경우
        - 같은 UID라도 변수 개수나 타입 등이 다른 경우
        

---

## transient 예약어

- 객체를 저장하거나 다른 JVM으로 보낼 때 transient라는 예약어를 사용하여 선언한 변수는 Serializable의 대상에서 제외된다.
- 이는 해당 객체가 저장 대상에서 제외되어 버림을 의미한다.

```jsx
transient private int bookOrder;
```

- 그러면 뭐하러 해당 예약어를 명시해서 변수를 만드는 것일까
    - 패스워드를 보관하고 있는 변수가 있는 경우에 해당 변수가 저장되거나 전송된다면 보안상 큰 문제가 발생할 수 있어, 보안상 중요한 변수나 꼭 저장해야 할 필요가 없는 변수에 대해서 transient를 사용한다.
    

---

## JDK 1.4부터 NIO라는 것이 추가된 이유

- 단 하나, 속도 때문이다.
- NIO는 지금까지 사용한 스트림이 아닌, 채널과 버퍼를 사용한다.
    - 채널 : 물건을 중간에서 처리하는 도매상
        - Stream의 경우 데이터를 읽기 위해서 입, 출력 스트림을 각 생성해야하는 반면 채널은 양방향 입출력이 가능하여 하나의 채널에 읽기, 쓰기가 모두 가능하다.
        - 채널은 비동기적으로 데이터를 읽거나, 쓸 수 있다.
        - 채널은 항상 버퍼로 데이터를 읽어들이거나, 쓰도록 되어 있다.
        - 입, 출력 수행 시 블로킹, 넌블로킹 특징을 모두 지원한다.
            - 블로킹 : 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 다른 작업이 끝날 때까지 기다렸다가 자신의 작업을 시작하는 것
            - 논블로킹 : 다른 주체의 작업에 관련없이 자신의 작업을 하는 것
    - 버퍼 : 도매상에서 물건을 사고 소비자에게 물건을 파는 소매상
        - 버퍼는 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역을 의미한다.
        - 버퍼는 컴퓨터 안의 프로세스 사이에서 데이터를 이동시킬 때 사용된다.
        - 데이터를 묶어 한 번에 전달하는 장점을 통해 전송 시간이 줄어, 성능이 향상된다.
        - 흙더미를 삽으로 퍼서 옮길 때 한 번씩 옮기는 것보다 포대(버퍼)에 담아 옮기는 것이 효율적임을 연상하면 이해가 쉽다.


![1](https://user-images.githubusercontent.com/56379649/218321972-8f6da3fc-306f-4c0c-b664-c50fa02914c0.png)



![2](https://user-images.githubusercontent.com/56379649/218321980-8f09bf51-82c6-4a09-a540-403eb419eff1.png)

