
> 정리
> 

- 제네릭을 사용하는 이유는 타입 형 변환에서 발생할 수 있는 문제점을 
컴파일할 때 점검하여 없애기 위해서이다.
- 꺾쇠 안에는 현재 존재하는 클래스를 사용해도 되고 존재하지 않는 것을 사용해도 된다.
- 물론 제네릭 꺽쇠 내 타입 여러 개도 사용할 수 있다. (”<K, V>”)
- 단, 되도록이면 클래스 이름의 명명 규칙과 동일하게 지정하는 것이 좋다.

---

### 제네릭 타입의 이름 정하기

자바에서 정의한 기본 규칙이 있다. 

- E : 요소
- K : 키
- N : 숫자
- T : 타입
- V : 값
- S, U, V : 두 번째, 세 번째, 네 번째에 선언된 타입

---

### <?>, 제네릭 와일드 카드

- 보통 와일드카드는 메서드의 매개 변수로만 사용하는 것이 좋다.
- 어떤 객체를 wildcard로 선언하고, 그 객체의 값을 가져올 수는 있으나, 와일드 카드로 객체를 선언했을 때에는 특정 타입으로 값을 지정하는 것이 불가능하여 정상적인 컴파일이 되지 않으니, 이 점을 유의하여 사용해야 한다.

### 제네릭 선언에 사용하는 타입의 범위도 지정할 수 있다.

- 다음과 같이 사용하는 것으로 Bounded Wildcards라고 부르곤 한다.
- 보통 매개 변수로 넘어오는 제네릭 타입의 경계를 지정하는 데 사용하는 의미로 해석된다.
    - ? ⇒ ? extends 타입

---

### 제네릭의 장점

1. 컴파일 시 강한 타입 체크를 할 수 있다. 
    - 컴파일 시 에러를 다 포착해내기 때문에 런타임 에러를 방지할 수 있다.
2. 타입 변환을 제거한다. (casting)
    - 다음과 같이 제네릭을 사용하지 않으면 강제 형 변환이 필요하여 성능에 악영향을 미친다.
    
    ```jsx
    List list = new ArrayList();
    list.add(1);
    
    Integer number = (Integer) list.get(0);
    ```
    
    - 제네릭을 사용하지 않으면 다양한 종류의 객체를 저장할 수 있다.
    - 하지만, 제네릭없이 다양한 타입의 데이터가 저장될 경우 
    타입 변환이 발생하고 읽어올 때도 타입 변환이 발생되게 된다.
    
    ```jsx
    List list = new ArrayList();
    list.add(1);
    list.add("a");
    list.add(0.1);
    
    Object o1 = list.get(0);
    Object o2 = list.get(1);
    Object o3 = list.get(2);
    
    Integer num = (Integer) o1;
    String str = (String) o2;
    Long L = (Long) o3;
    ```
    
    - 아래와 같이 제네릭을 사용하는 경우 List에 저장되는 요소의 타입을 제한하기 때문에 
    추가적인 타입 변환이 없어 프로그램 성능은 향상되게 된다.
